Key combo recognition and handling {#hotkeys}
==================================

Key combinations are stored in a tree, with each node representing one key
press.
The subsystem will hold a pointer to one of the nodes (in addition to the root
node) which represents the state of a state machine interpreting the input
given by the user.
If the user presses a key, the next adjacent node with the corresponding
keycode is selected as the current key.
If no such node exists, the state is reset by setting the pointer to the root
node.
This way, input generated by the user causes the subsystem to traverse the
tree downwards.

When the user releases the last of the keys he kept pressed and an event is
attached to the currently selected node of the DAG, that event is triggered and
the state machine is reset.
If no event is attached to a node selected when the user releases the last key,
the state machine still will be reset.
However, instead of triggering an event, the keys the user held pressed are
emitted to the program.

The DAG, which is really a tree, may look like the following:

        <root>
       /      \
     Ctrl    Meta
      |       |
    Shift     W
     / \
    C   X


This tree holds the following key-combinations:
 * Ctrl + Shift + C
 * Ctrl + Shift + X
 * Meta + W

Each of those combinations may trigger an event.
Also, each combination is triggered only if the user presses those keys in
that order.
The order in which the keys are released is irrelevant.
Also, the keys don't have to be pressed all at the same time.
E.g. if a user wishes to trigger the event attached to the bottom left node, he
or she may press Ctrl, Shift, _release_ one of those keys, press "C" and then
release "C" and the key left in any order.


DAG node data structure
-----------------------

The number of children a DAG node has is expected to vary, all the key-codes
are allowed, as any possible key combination should be possible.
The most natural way to construct a node would be to have an array of pointers
for each possible code.
However, having an array of 2^16 elements in each node uses up a lot of memory.
Using a linked list also isn't an option, since this would cause lookup times
in `O(n)`.

Instead, another tree is used for hierarchical lookups of children.
We'll call such a tree a "table" in this context, because we will look up
children in it.
In this tree, each node may have up to 16 children.
Using this tree, we would need a depth of four to cover the entire range of
key-codes.
However, most of the time, less is sufficient.
E.g. consider a DAG node which has children for the key-codes `KEY_Q` (`0x10`)
and `KEY_X` (`0x2D`).
Clearly, not all of the branches have to be filled with nodes, which means we
don't have to allocate memory for them.
Hence, a "table" tree would look like this:


          0000-ffff
              |
          0000-0fff
              |
          0000-00ff
         /         \
    0010-001f   0020-002f
        |           |
       "Q"         "X"


It doesn't need a keen eye to see that the first two nodes are not really
functional, which means that they may be omitted.
Also, all the keys are stored in leaves which are _all_ on the same level.
Hence, the implementation used in this module used minimal nodes, which
basically are arrays of pointers and fixed in size.
The depth of the tree is stored in a struct, which also holds the lowest
key-code which may be stored in the subtree:


    {depth: 1, start: 0x0}
              |
          0000-00ff
         /         \
    0010-001f   0020-002f
        |           |
       "Q"         "X"


If a key is inserted which does not fit into the current subtree, a new
root node is put on top of the current subtree and all the nodes which are
needed are added to the tree.

When traversing the table tree, the `start` has to be recalculated for each
node as the node itself doesn't hold it.
For any node, the start can be easily calculated from the depth and a code
which is _in_ the subtree by masking out all the bits corresponding to the
levels in the subtree in question.

In the tree shown above, if we search for `KEY_X` (`0x2D`), we start with
a depth of `1` and a start of `0x00`.
We determine that the child node we're interested in is
`((0x2D - start) >> (4 * depth)) & 0x0F`, which is `0x02`.
After selecting that node, we regenerate `start` by taking the code and
masking out the last four bits, which correspond to the final level.
The new `start` is thus `0x2D & ~0x0F` or `0x20`.
The element which refers to the DAG node we're interested in is
`((0x2D - start) >> (4 * depth)) & 0x0F` which now evaluates to `0x0D`
(note that we also decremented `depth`).

